<script>
const $ = id => document.getElementById(id);
const CHAR_LIMIT = 500;
const EXEMPT = 'fries';
let currentUser = null;
let shown = new Set();

/* styles for embedded content */
const style = document.createElement('style');
style.textContent = `
.embedded-image{max-width:100%;border-radius:8px;margin-top:8px;display:block}
.link-preview{display:flex;gap:10px;align-items:flex-start;border-radius:8px;padding:8px;margin-top:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03)}
.link-preview img.favicon{width:28px;height:28px;border-radius:6px;flex:0 0 28px;object-fit:cover}
.link-preview .meta{display:flex;flex-direction:column}
.link-preview .meta .title{font-weight:700;color:var(--ink)}
.link-preview .meta .desc{color:var(--muted);font-size:13px;margin-top:4px}
`;
document.head.appendChild(style);

/* render markdown then enhance links/images */
function renderMd(md){
  try { return DOMPurify.sanitize(marked.parse(md||'')); }
  catch(e){ return DOMPurify.sanitize(md||''); }
}

/* quick domain helper */
function domainFromUrl(u){
  try { return new URL(u).hostname.replace(/^www\./, ''); } catch(e){ return u; }
}

/* detect image URL */
const IMG_RE = /\.(jpe?g|png|gif|webp|avif|svg)(\?.*)?$/i;

/* try to fetch page HTML and extract title + description og/meta; may fail due to CORS */
async function fetchPageMeta(href){
  try{
    const res = await fetch(href, { mode: 'cors' });
    const text = await res.text();
    const doc = new DOMParser().parseFromString(text, 'text/html');
    const title = doc.querySelector('meta[property="og:title"]')?.content
                || doc.querySelector('meta[name="title"]')?.content
                || doc.querySelector('title')?.textContent
                || null;
    const desc = doc.querySelector('meta[property="og:description"]')?.content
              || doc.querySelector('meta[name="description"]')?.content
              || null;
    return { title, desc };
  }catch(e){
    return null;
  }
}

/* build fallback preview node */
function makeFallbackPreview(href){
  const div = document.createElement('div');
  div.className = 'link-preview';
  const fav = document.createElement('img');
  fav.className = 'favicon';
  fav.src = 'https://www.google.com/s2/favicons?domain=' + encodeURIComponent(domainFromUrl(href));
  fav.alt = '';
  fav.loading = 'lazy';
  fav.classList.add('favicon');
  const meta = document.createElement('div');
  meta.className = 'meta';
  const title = document.createElement('div');
  title.className = 'title';
  title.textContent = domainFromUrl(href);
  const desc = document.createElement('div');
  desc.className = 'desc';
  desc.textContent = href;
  meta.appendChild(title);
  meta.appendChild(desc);
  div.appendChild(fav);
  div.appendChild(meta);
  // make clickable
  div.addEventListener('click', ()=> window.open(href, '_blank', 'noopener'));
  return div;
}

/* populate preview node with fetched meta */
function fillPreviewNode(node, href, meta){
  node.innerHTML = '';
  const fav = document.createElement('img');
  fav.className = 'favicon';
  fav.src = 'https://www.google.com/s2/favicons?domain=' + encodeURIComponent(domainFromUrl(href));
  fav.alt = '';
  fav.loading = 'lazy';
  const metaWrap = document.createElement('div');
  metaWrap.className = 'meta';
  const title = document.createElement('div');
  title.className = 'title';
  title.textContent = meta?.title || domainFromUrl(href);
  const desc = document.createElement('div');
  desc.className = 'desc';
  desc.textContent = meta?.desc || href;
  metaWrap.appendChild(title);
  metaWrap.appendChild(desc);
  node.appendChild(fav);
  node.appendChild(metaWrap);
  node.addEventListener('click', ()=> window.open(href, '_blank', 'noopener'));
}

/* takes sanitized HTML string, returns element with images inserted and previews appended.
   Previews that need metadata fetch are filled asynchronously; function returns immediately. */
function enhanceHtmlToNode(sanitizedHtml){
  const container = document.createElement('div');
  container.innerHTML = sanitizedHtml;

  // replace markdown image syntax already handled by marked; we still detect bare links
  const anchors = Array.from(container.querySelectorAll('a[href]'));
  anchors.forEach(a=>{
    const href = a.href;
    // image URL -> replace anchor with <img>
    if (IMG_RE.test(href)){
      const img = document.createElement('img');
      img.src = href;
      img.className = 'embedded-image';
      img.alt = a.textContent || '';
      img.loading = 'lazy';
      a.replaceWith(img);
      return;
    }

    // non-image link -> append preview placeholder after the anchor
    const previewNode = document.createElement('div');
    previewNode.className = 'link-preview';
    previewNode.textContent = 'Loading preview...';
    // insert after link
    if (a.parentNode) {
      a.parentNode.insertBefore(previewNode, a.nextSibling);
    }
    // async fetch meta
    (async ()=>{
      const meta = await fetchPageMeta(href);
      if (meta){
        fillPreviewNode(previewNode, href, meta);
      } else {
        const fallback = makeFallbackPreview(href);
        previewNode.replaceWith(fallback);
      }
    })();
  });

  // also detect raw URLs in plain text nodes (not links) and convert image URLs to images and other URLs to links+preview
  const treeWalker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null, false);
  const textNodes = [];
  while(treeWalker.nextNode()) textNodes.push(treeWalker.currentNode);
  const URL_RE = /https?:\/\/[^\s<>'"]+/g;
  textNodes.forEach(tn=>{
    const str = tn.nodeValue;
    if (!str) return;
    const matches = [...str.matchAll(URL_RE)];
    if (matches.length === 0) return;
    const frag = document.createDocumentFragment();
    let lastIndex = 0;
    matches.forEach(m=>{
      const idx = m.index;
      const url = m[0];
      // text before
      if (idx > lastIndex) frag.appendChild(document.createTextNode(str.slice(lastIndex, idx)));
      // create anchor or image
      if (IMG_RE.test(url)){
        const img = document.createElement('img');
        img.src = url;
        img.className = 'embedded-image';
        img.alt = '';
        img.loading = 'lazy';
        frag.appendChild(img);
      } else {
        const a = document.createElement('a');
        a.href = url;
        a.textContent = url;
        a.target = '_blank';
        a.rel = 'noopener noreferrer';
        frag.appendChild(a);
        // preview placeholder
        const previewNode = document.createElement('div');
        previewNode.className = 'link-preview';
        previewNode.textContent = 'Loading preview...';
        frag.appendChild(previewNode);
        (async ()=>{
          const meta = await fetchPageMeta(url);
          if (meta) fillPreviewNode(previewNode, url, meta);
          else {
            const fallback = makeFallbackPreview(url);
            previewNode.replaceWith(fallback);
          }
        })();
      }
      lastIndex = idx + url.length;
    });
    if (lastIndex < str.length) frag.appendChild(document.createTextNode(str.slice(lastIndex)));
    tn.parentNode.replaceChild(frag, tn);
  });

  return container;
}

/* create post element (uses enhancement) */
function makePostEl(p){
  const el = document.createElement('div');
  el.className = 'post';
  const metaHtml = `
    <div class="meta">
      <div class="author">${escapeHtml(p.author)}</div>
      <div class="timestamp">${new Date(p.timestamp).toLocaleString()}</div>
    </div>
  `;
  el.innerHTML = metaHtml;
  const contentDiv = document.createElement('div');
  contentDiv.className = 'content';
  const sanitized = renderMd(p.content||'');
  const enhancedNode = enhanceHtmlToNode(sanitized);
  // move children into contentDiv
  while(enhancedNode.firstChild) contentDiv.appendChild(enhancedNode.firstChild);
  el.appendChild(contentDiv);
  return el;
}

function prependPost(p){
  if (!p || !p.id) return;
  if (shown.has(p.id)) return;
  const node = makePostEl(p);
  $('posts').insertBefore(node, $('posts').firstChild);
  shown.add(p.id);
}

/* rest of code unchanged: loadPosts, whoami, refreshUI, auth, composer, etc. */

async function loadPosts(){
  const res = await fetch('/posts');
  const arr = await res.json();
  // newest-first
  arr.sort((a,b)=> new Date(b.timestamp) - new Date(a.timestamp));
  $('posts').innerHTML = '';
  shown.clear();
  for (const p of arr) {
    const node = makePostEl(p);
    $('posts').appendChild(node);
    shown.add(p.id);
  }
}

async function whoami(){
  try{
    const r = await fetch('/me');
    if (!r.ok) return { user: null };
    return await r.json();
  } catch { return { user: null }; }
}

async function refreshUI(){
  const m = await whoami();
  currentUser = m.user || null;
  if (currentUser){
    $('meName').textContent = currentUser;
    $('meSub').textContent = 'signed in';
    $('logoutBtn').style.display = 'inline-block';
    $('displayName').textContent = currentUser;
    $('authCard').style.display = 'none';
  } else {
    $('meName').textContent = '';
    $('meSub').textContent = 'not signed in';
    $('logoutBtn').style.display = 'none';
    $('displayName').textContent = 'guest';
    $('authCard').style.display = '';
  }
}

// auth flows
let signingUp = false;
$('toggleAuth').addEventListener('click', ()=> {
  signingUp = !signingUp;
  $('authBtn').textContent = signingUp ? 'Sign up' : 'Login';
  $('toggleAuth').textContent = signingUp ? 'Have an account?' : 'Sign up';
});

$('authBtn').addEventListener('click', async ()=>{
  const u = $('u_name').value.trim(), p = $('u_pass').value.trim();
  if (!u || !p) return alert('username + password required');
  const ep = signingUp ? '/signup' : '/login';
  const res = await fetch(ep, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ username: u, password: p })});
  const j = await res.json().catch(()=>({}));
  if (!res.ok) return alert(j.error || 'auth failed');
  $('u_name').value=''; $('u_pass').value='';
  await refreshUI();
  await loadPosts();
});

$('logoutBtn').addEventListener('click', async ()=>{
  await fetch('/logout',{ method:'POST' }).catch(()=>{});
  currentUser = null; shown.clear();
  await refreshUI();
  await loadPosts();
});

// composer
$('content').addEventListener('input', ()=> {
  const left = CHAR_LIMIT - $('content').value.length;
  $('charsLeft').textContent = left;
});

$('previewBtn').addEventListener('click', ()=> {
  const raw = $('content').value || '';
  const sanitized = renderMd(raw);
  const node = enhanceHtmlToNode(sanitized);
  $('preview').innerHTML = '';
  while(node.firstChild) $('preview').appendChild(node.firstChild);
  $('preview').style.display = $('preview').style.display === 'none' ? 'block' : 'none';
});

$('postBtn').addEventListener('click', async ()=>{
  const content = $('content').value.trim();
  if (!content) return alert('write something first');
  if (content.length > CHAR_LIMIT) return alert(`max ${CHAR_LIMIT} chars`);
  if (!currentUser) return alert('log in to post');

  const res = await fetch('/posts', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ content })});
  const j = await res.json().catch(()=>({}));
  if (!res.ok) return alert(j.error || 'post failed');
  const newPost = j.post || j;
  confetti({ particleCount: 45, spread: 70, origin: { y: 0.35 }});
  prependPost(newPost);
  $('content').value = ''; $('charsLeft').textContent = CHAR_LIMIT; $('preview').style.display='none';
});

// helpers
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m])); }

// init
(async function init(){
  await refreshUI();
  await loadPosts();
  setInterval(async ()=>{
    try{
      const res = await fetch('/posts');
      const arr = await res.json();
      for (const p of arr) if (!shown.has(p.id)) prependPost(p);
    }catch(e){}
  },7000);
  setInterval(()=> $('composerClock').textContent = new Date().toLocaleTimeString(), 1000);
})();
</script>
